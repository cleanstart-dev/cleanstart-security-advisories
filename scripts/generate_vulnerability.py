#!/usr/bin/env python3
"""
Script to generate CleanStart vulnerability JSON files in OSV format.
Supports both single and batch creation with comprehensive fields.
Creates files with the format: CLEANSTART-YYYY-LLNNNNN.json
"""

import contextlib
import json
import os
import sqlite3
import subprocess
import sys
import random
import string
from collections import defaultdict
from datetime import datetime
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
ADVISORIES_DIR = BASE_DIR / "advisories"
SCAN_RESULTS_DIR = BASE_DIR / "scan_results"
SCHEMA_ENV_OVERRIDE = os.environ.get("CLEANSTART_OSV_SCHEMA")
SCHEMA_PATH = (
    Path(SCHEMA_ENV_OVERRIDE).expanduser()
    if SCHEMA_ENV_OVERRIDE
    else BASE_DIR / "validation" / "schemas" / "osv-schema-1.7.4.json"
)
SQLITE_DB_PATH = BASE_DIR / "data" / "vulnstatus.db"

SEVERITY_ORDER = {
    "CRITICAL": 5,
    "HIGH": 4,
    "MEDIUM": 3,
    "LOW": 2,
    "UNKNOWN": 1,
    "NEGLIGIBLE": 1,
}


def validate_osv_file(json_path):
    """Validate a vulnerability JSON against the OSV schema using check-jsonschema."""
    if not SCHEMA_PATH:
        raise RuntimeError("OSV schema path is not configured.")
    if not SCHEMA_PATH.exists():
        raise FileNotFoundError(
            f"Schema file not found at {SCHEMA_PATH}. "
            "Set CLEANSTART_OSV_SCHEMA to override the path or download the schema."
        )

    cmd = [
        "check-jsonschema",
        "--schemafile",
        str(SCHEMA_PATH),
        str(json_path),
    ]
    try:
        subprocess.run(cmd, check=True, capture_output=True, text=True)
        print(f"  ‚úì Schema validation passed for {json_path.name}")
    except FileNotFoundError:
        print("  ! check-jsonschema command not found. Install it to enable auto-validation.")
    except subprocess.CalledProcessError as exc:
        print(f"  ‚úó Schema validation failed for {json_path}")
        if exc.stdout:
            print(exc.stdout.strip())
        if exc.stderr:
            print(exc.stderr.strip())
        raise



def get_existing_ids(vulnerabilities_dir):
    """
    Get all existing vulnerability ID numbers for the given year directory.
    Returns a set of ID suffixes (e.g., 'AB12345').
    """
    existing_ids = set()
    
    if not vulnerabilities_dir.exists():
        return existing_ids
    
    # Find all existing vulnerability files
    existing_files = list(vulnerabilities_dir.glob("CLEANSTART-*.json"))
    
    for file in existing_files:
        filename = file.stem  # Remove .json extension
        # Extract the ID suffix (e.g., AB12345)
        parts = filename.split("-")
        if len(parts) == 3:
            existing_ids.add(parts[2])
    
    return existing_ids


def fetch_aliases_for_package(package_name):
    """
    Look up distinct CVE identifiers for a given package from the SQLite database.
    """
    if not package_name or not SQLITE_DB_PATH.exists():
        return []

    try:
        conn = sqlite3.connect(SQLITE_DB_PATH)
        cur = conn.cursor()
        cur.execute(
            """
            SELECT DISTINCT cve
            FROM vuln_status
            WHERE cve IS NOT NULL
              AND cve != ''
              AND cve != 'NO_CVE'
              AND UPPER(library) = UPPER(?)
            ORDER BY cve
            """,
            (package_name,),
        )
        results = [row[0] for row in cur.fetchall()]
    except sqlite3.Error:
        results = []
    finally:
        try:
            conn.close()
        except Exception:
            pass

    return results


def fetch_package_data_from_db(package_name):
    """
    Fetch comprehensive vulnerability data for a package from SQLite database.
    Returns a dict with: aliases, description, severity, fixed_versions, installed_versions, references
    """
    if not package_name or not SQLITE_DB_PATH.exists():
        return None

    try:
        conn = sqlite3.connect(SQLITE_DB_PATH)
        cur = conn.cursor()
        cur.execute(
            """
            SELECT DISTINCT cve, description, severity, fixed_version, installed_version
            FROM vuln_status
            WHERE UPPER(library) = UPPER(?)
              AND cve IS NOT NULL
              AND cve != ''
              AND cve != 'NO_CVE'
            ORDER BY updated DESC
            """,
            (package_name,),
        )
        rows = cur.fetchall()
        conn.close()

        if not rows:
            return None

        # Collect data
        aliases = sorted(set(row[0] for row in rows if row[0]))
        descriptions = [row[1] for row in rows if row[1] and row[1].strip()]
        severities = [row[2] for row in rows if row[2] and row[2].strip()]
        fixed_versions = []
        installed_versions = []
        entries = []

        for row in rows:
            entry = {
                "cve": row[0],
                "description": row[1] or "",
                "severity": row[2] or "",
                "fixed_version": row[3] or "",
                "installed_version": row[4] or "",
            }
            entries.append(entry)
            if row[3]:  # fixed_version
                # Parse comma-separated fixed versions
                for fv in row[3].split(','):
                    fv = fv.strip()
                    if fv and fv not in fixed_versions:
                        fixed_versions.append(fv)
            if row[4]:  # installed_version
                if row[4] not in installed_versions:
                    installed_versions.append(row[4])

        # Get most common severity
        severity = None
        if severities:
            from collections import Counter
            severity = Counter(severities).most_common(1)[0][0]

        # Get best description (longest non-empty)
        description = ""
        if descriptions:
            description = max(descriptions, key=len)

        return {
            "aliases": aliases,
            "description": description,
            "severity": severity,
            "fixed_versions": sorted(fixed_versions),
            "installed_versions": sorted(installed_versions),
            "entries": entries,
        }
    except sqlite3.Error:
        return None
    except Exception:
        return None


def generate_random_vulnerability_id(year, vulnerabilities_dir):
    """
    Generates a random vulnerability ID for the given year.
    Format: CLEANSTART-YYYY-LLNNNNN (2 uppercase letters + 5 digits)
    Ensures the ID doesn't already exist.
    """
    existing_ids = get_existing_ids(vulnerabilities_dir)
    
    # Generate random ID with 2 letters + 5 digits
    max_attempts = 100
    for _ in range(max_attempts):
        # Generate 2 random uppercase letters
        letters = ''.join(random.choices(string.ascii_uppercase, k=2))
        # Generate 5 random digits
        numbers = ''.join(random.choices(string.digits, k=5))
        id_suffix = f"{letters}{numbers}"
        
        if id_suffix not in existing_ids:
            return f"CLEANSTART-{year}-{id_suffix}"
    
    # If we couldn't find a random ID (very unlikely), try systematically
    for letter1 in string.ascii_uppercase:
        for letter2 in string.ascii_uppercase:
            for num in range(100000):
                id_suffix = f"{letter1}{letter2}{num:05d}"
                if id_suffix not in existing_ids:
                    return f"CLEANSTART-{year}-{id_suffix}"
    
    raise ValueError("No available ID numbers (all IDs used for this year)")



def normalize_severity(value):
    """Normalize severity strings to uppercase keywords."""
    if not value:
        return "UNKNOWN"
    return str(value).strip().upper()


def severity_rank(value):
    """Convert severity labels to numeric ranks for comparisons."""
    return SEVERITY_ORDER.get(normalize_severity(value), 0)


def summarize_text(text, package_name, alias=None):
    """Generate a concise summary line from description text."""
    if not text:
        if alias:
            return f"{package_name} vulnerability tracked as {alias}."
        return f"Security vulnerability in {package_name}"

    lines = [line.strip() for line in text.split("\n") if line.strip()]
    for line in lines:
        if line.startswith("#"):
            continue
        candidate = line
        if "." in candidate:
            candidate = candidate.split(".")[0].strip()
        candidate = candidate[:150].rstrip()
        if candidate:
            return candidate + ("" if candidate.endswith(".") else ".")
    fallback = lines[0][:150].rstrip() if lines else text[:150].rstrip()
    suffix = f" ({alias})." if alias and not fallback.endswith(".") else "."
    if fallback.endswith("."):
        return fallback
    return fallback + suffix


def guess_introduced_version(version_hint):
    """Best-effort introduced version derived from installed/fixed hints."""
    if not version_hint:
        return "0"
    version_hint = version_hint.strip()
    parts = version_hint.split(".")
    if len(parts) >= 2:
        return f"{parts[0]}.{parts[1]}.0"
    return "0"


def generate_advisories_from_db_entries(package_name, db_data, year, output_dir):
    """Create a separate advisory for each CVE stored in the database."""
    entries = db_data.get("entries") or []
    if not entries:
        print("\n‚ö†Ô∏è  No per-CVE entries found in the database.")
        return []

    created_files = []
    for entry in entries:
        cve = entry.get("cve")
        if not cve:
            continue

        description = entry.get("description") or ""
        summary = summarize_text(description, package_name, cve)
        details_lines = [
            description.strip() or f"No detailed description was provided for {cve}.",
            "",
            f"This advisory tracks {cve} impacting package {package_name}.",
        ]
        if entry.get("installed_version"):
            details_lines.append(
                f"Affected version observed: {entry['installed_version']}."
            )
        if entry.get("fixed_version"):
            details_lines.append(f"Fixed in version: {entry['fixed_version']}.")
        details_lines.append(
            "Source: CleanStart vulnerability database auto-import."
        )
        details = "\n".join(details_lines)

        introduced = guess_introduced_version(
            entry.get("installed_version") or entry.get("fixed_version")
        )
        events = [{"introduced": introduced}]
        if entry.get("fixed_version"):
            events.append({"fixed": entry["fixed_version"]})

        affected_entry = {
            "package": {"ecosystem": "CLEANSTART", "name": package_name},
            "ranges": [
                {
                    "type": "ECOSYSTEM",
                    "events": events,
                }
            ],
        }
        if entry.get("installed_version"):
            affected_entry["versions"] = [entry["installed_version"]]

        references = [
            {"type": "WEB", "url": f"https://nvd.nist.gov/vuln/detail/{cve}"}
        ]

        severity = []
        severity_label = normalize_severity(entry.get("severity"))
        if severity_label and severity_label != "UNKNOWN":
            severity.append({"type": "CUSTOM", "score": severity_label})

        vuln_id = generate_random_vulnerability_id(year, output_dir)
        timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
        advisory = {
            "schema_version": "1.7.3",
            "id": vuln_id,
            "modified": timestamp,
            "published": timestamp,
            "withdrawn": None,
            "aliases": [cve],
            "summary": summary,
            "details": details,
            "affected": [affected_entry],
            "references": references,
            "severity": severity,
        }

        filepath = save_vulnerability(advisory, output_dir)
        created_files.append(filepath.name)
        print(f"  ‚úì Created advisory {filepath.name} for {cve}")

    if created_files:
        print(
            f"\n‚úì Generated {len(created_files)} per-CVE advisories in {output_dir}"
        )
    else:
        print("\n‚ö†Ô∏è  No advisories were generated from the database entries.")
    return created_files


def collect_scan_records(scan_root):
    """Walk the scan_results tree and gather vulnerability records."""
    scan_root = Path(scan_root)
    if not scan_root.exists():
        raise FileNotFoundError(f"Scan results directory not found: {scan_root}")

    records = []
    for vuln_file in scan_root.rglob("vulnerabilities.json"):
        try:
            with open(vuln_file, encoding="utf-8") as fh:
                data = json.load(fh)
        except Exception as exc:
            print(f"  ! Skipping {vuln_file}: {exc}")
            continue

        metadata = data.get("Metadata") or {}
        artifact = (
            data.get("ArtifactName")
            or (metadata.get("RepoTags") or [None])[0]
            or (metadata.get("RepoDigests") or [None])[0]
            or vuln_file.parent.name
        )

        results = data.get("Results") or []
        vulnerabilities = []
        for result in results:
            for vuln in result.get("Vulnerabilities") or []:
                cve = (
                    vuln.get("VulnerabilityID")
                    or vuln.get("CVE")
                    or vuln.get("id")
                    or vuln.get("ID")
                )
                if not cve:
                    continue
                cvss_vector = None
                cvss_data = vuln.get("CVSS") or vuln.get("cvss")
                if isinstance(cvss_data, str):
                    cvss_vector = cvss_data.strip()
                elif isinstance(cvss_data, dict):
                    cvss_vector = (
                        cvss_data.get("vector")
                        or cvss_data.get("Vector")
                        or cvss_data.get("V3Vector")
                        or cvss_data.get("CvssV3Vector")
                    )
                    if isinstance(cvss_data.get("v3Vector"), str):
                        cvss_vector = cvss_data["v3Vector"]
                elif vuln.get("CVSSScore"):
                    cvss_vector = vuln.get("CVSSScore")
                if isinstance(vuln.get("CVSSV3"), str):
                    cvss_vector = vuln.get("CVSSV3")
                if isinstance(vuln.get("cvssV3Vector"), str):
                    cvss_vector = vuln.get("cvssV3Vector")

                pkg_name = (
                    vuln.get("PkgName")
                    or vuln.get("pkgName")
                    or vuln.get("PackageName")
                    or "unknown-package"
                )
                vulnerabilities.append(
                    {
                        "cve": cve,
                        "package": pkg_name,
                        "pkg_type": vuln.get("PkgType") or vuln.get("PkgPath"),
                        "installed_version": vuln.get("InstalledVersion") or vuln.get("PkgVersion"),
                        "fixed_version": vuln.get("FixedVersion"),
                        "severity": normalize_severity(vuln.get("Severity")),
                        "cvss": cvss_vector,
                        "description": vuln.get("Description") or vuln.get("Title") or "",
                        "primary_url": vuln.get("PrimaryURL"),
                        "references": vuln.get("References") or [],
                    }
                )

        if not vulnerabilities:
            continue

        records.append(
            {
                "artifact": artifact,
                "folder": vuln_file.relative_to(scan_root).parent.as_posix(),
                "path": vuln_file,
                "created_at": data.get("CreatedAt"),
                "vulnerabilities": vulnerabilities,
            }
        )
    return records



def build_details_text(record, vulnerabilities):
    """Create structured prose summarizing a grouped set of vulnerabilities."""
    package = vulnerabilities[0]["package"]
    description = (vulnerabilities[0].get("description") or "").strip()
    severity_label = normalize_severity(vulnerabilities[0].get("severity"))
    versions = sorted(
        {
            v.get("installed_version")
            for v in vulnerabilities
            if v.get("installed_version")
        }
    )
    fixed_version = vulnerabilities[0].get("fixed_version")

    lines = []
    if description:
        lines.append(description)
    else:
        lines.append(
            f"The scanner reported a vulnerability affecting {package}, but it did not include a detailed description."
        )

    if severity_label and severity_label != "UNKNOWN":
        lines.append("")
        lines.append(f"Impact: The scanner rated this issue as {severity_label}.")

    lines.append("")
    if versions:
        lines.append(
            f"Affected versions: {', '.join(versions)}."
        )
    else:
        lines.append("Affected versions: The scanner did not provide explicit version identifiers.")

    lines.append("")
    lines.append("Included CVEs:")
    for vuln in vulnerabilities:
        fixed = vuln.get("fixed_version")
        fix_clause = f" (fixed in {fixed})" if fixed else ""
        lines.append(f"- {vuln['cve']}{fix_clause}")

    lines.append("")
    if fixed_version:
        lines.append(f"Remediation: Upgrade {package} to {fixed_version} or a later release.")
    else:
        lines.append(f"Remediation: Apply the vendor's recommended update for {package} when available.")

    lines.append("")
    lines.append(
        f"Scan metadata: detected in artifact `{record['artifact']}` under scan folder `{record['folder']}`."
    )

    return "\n".join(lines)


def group_vulnerabilities_for_advisory(vulnerabilities):
    """
    Cluster vulnerabilities by package/description/fix/severity so only matching
    issues are grouped into the same advisory.
    """
    grouped = defaultdict(list)
    for vuln in vulnerabilities:
        key = (
            vuln["package"],
            (vuln.get("description") or "").strip(),
            vuln.get("fixed_version") or "",
            normalize_severity(vuln.get("severity")),
        )
        grouped[key].append(vuln)
    return list(grouped.values())


def build_advisories_from_scan(record, year, year_dir):
    """Convert a scan record into one or more OSV advisories."""
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    grouped_vulns = group_vulnerabilities_for_advisory(record["vulnerabilities"])
    advisories = []

    for group in grouped_vulns:
        vuln_id = generate_random_vulnerability_id(year, year_dir)
        aliases = sorted({v["cve"] for v in group if v.get("cve")})
        if not aliases:
            continue

        package = group[0]["package"]
        description = (group[0].get("description") or "").strip()
        summary = description.split(".")[0].strip() if description else ""
        if summary:
            summary = summary.rstrip(".") + "."
        else:
            summary = f"Vulnerability affecting {package} detected in {record['artifact']}."
        details = build_details_text(record, group)

        versions = sorted(
            {
                v.get("installed_version")
                for v in group
                if v.get("installed_version")
            }
        )
        locations = sorted(
            {v.get("pkg_type") for v in group if v.get("pkg_type")}
        )
        fixed_version = group[0].get("fixed_version")

        range_events = [{"introduced": "0"}]
        if fixed_version:
            range_events.append({"fixed": fixed_version})

        affected_entry = {
            "package": {"ecosystem": "CLEANSTART", "name": package},
            "ranges": [
                {
                    "type": "ECOSYSTEM",
                    "events": range_events,
                }
            ],
        }
        if versions:
            affected_entry["versions"] = versions
        if locations:
            affected_entry.setdefault("database_specific", {})[
                "locations"
            ] = locations

        references = []
        seen_refs = set()

        scan_url = f"file://{record['path']}"
        references.append({"type": "REPORT", "url": scan_url})
        seen_refs.add(("REPORT", scan_url))

        for vuln in group:
            primary_url = vuln.get("primary_url")
            if primary_url:
                entry = ("WEB", primary_url)
                if entry not in seen_refs:
                    references.append({"type": "WEB", "url": primary_url})
                    seen_refs.add(entry)
            for ref in vuln.get("references") or []:
                if not ref:
                    continue
                entry = ("WEB", ref)
                if entry not in seen_refs:
                    references.append({"type": "WEB", "url": ref})
                    seen_refs.add(entry)

        severity = []
        cvss_vector = next((v.get("cvss") for v in group if v.get("cvss")), None)
        if cvss_vector:
            severity.append({"type": "CVSS_V3", "score": cvss_vector})
        else:
            severity_value = normalize_severity(group[0].get("severity"))
            if severity_value and severity_value != "UNKNOWN":
                severity.append({"type": "CUSTOM", "score": severity_value})

        advisories.append(
            {
                "schema_version": "1.7.3",
                "id": vuln_id,
                "modified": timestamp,
                "published": timestamp,
                "withdrawn": None,
                "aliases": aliases,
                "summary": summary,
                "details": details,
                "affected": [affected_entry],
                "references": references,
                "severity": severity,
                "database_specific": {
                    "source_scan_folder": record["folder"],
                    "artifact": record["artifact"],
                    "generated_from_scan": True,
                },
            }
        )

    return advisories

def get_multiline_input(prompt, allow_empty=False):
    """
    Get multiline input from user.
    """
    print(f"\n{prompt}")
    print("(Press Ctrl+D or Ctrl+Z then Enter when done, or enter '.' on a line by itself)")
    lines = []
    try:
        while True:
            line = input()
            if line == '.':
                break
            lines.append(line)
    except EOFError:
        pass
    
    result = '\n'.join(lines).strip()
    if not result and not allow_empty:
        return None
    return result


def get_list_input(prompt, allow_empty=True):
    """
    Get comma-separated list input from user.
    """
    response = input(f"\n{prompt}\n> ").strip()
    if not response:
        return [] if allow_empty else None
    return [item.strip() for item in response.split(',') if item.strip()]


def create_comprehensive_vulnerability_json(vuln_id, package_name="{package_name}", 
                                           summary="", details="", aliases=None, 
                                           references=None, severity=None, ranges=None, versions=None,
                                           published=None, withdrawn=None):
    """
    Creates a comprehensive vulnerability JSON object with all OSV fields.
    """
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    
    vulnerability = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "published": published or timestamp,
        "withdrawn": withdrawn,
        "aliases": aliases or [],
        "summary": summary or f"Security vulnerability in {package_name}",
        "details": details or "",
        "affected": [
            {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                }
            }
        ],
        "references": references or [],
        "severity": severity or []
    }
    
    # Add ranges if provided
    if ranges:
        vulnerability["affected"][0]["ranges"] = ranges
    
    # Add explicit versions if provided
    if versions:
        vulnerability["affected"][0]["versions"] = versions
    
    return vulnerability


def save_vulnerability(vuln_data, vulnerabilities_dir):
    """
    Saves the vulnerability JSON to the appropriate directory.
    """
    # Create directory structure if it doesn't exist
    vulnerabilities_dir.mkdir(parents=True, exist_ok=True)
    
    # Create filename
    vuln_id = vuln_data["id"]
    filename = f"{vuln_id}.json"
    filepath = vulnerabilities_dir / filename
    
    # Save JSON file with proper formatting
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(vuln_data, f, indent=2, ensure_ascii=False)

    try:
        validate_osv_file(filepath)
    except Exception:
        # Remove invalid file so callers can fix issues before retrying
        with contextlib.suppress(Exception):
            filepath.unlink(missing_ok=True)
        raise
    
    return filepath


def create_single_vulnerability_detailed():
    """
    Interactive mode to create a single comprehensive vulnerability file.
    """
    print("\n" + "=" * 60)
    print("Detailed Vulnerability Creation")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (required): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    # Fetch comprehensive data from database
    db_data = fetch_package_data_from_db(package_name)
    
    # Auto-fill from database if available
    if db_data:
        print("\n" + "=" * 60)
        print("üìä Data found in CleanStart database:")
        print("=" * 60)
        if db_data["aliases"]:
            print(f"  Aliases: {', '.join(db_data['aliases'])}")
        if db_data["description"]:
            desc_preview = db_data["description"][:100] + "..." if len(db_data["description"]) > 100 else db_data["description"]
            print(f"  Description: {desc_preview}")
        if db_data["severity"]:
            print(f"  Severity: {db_data['severity']}")
        if db_data["fixed_versions"]:
            print(f"  Fixed versions: {', '.join(db_data['fixed_versions'])}")
        if db_data["installed_versions"]:
            print(f"  Installed versions: {', '.join(db_data['installed_versions'])}")
        print("=" * 60)
        
        use_db_data = input("\nUse this database data? (Y/n): ").strip().lower()
        if use_db_data != 'n':
            # Auto-fill from database
            aliases = list(db_data["aliases"]) if db_data["aliases"] else []
            details = db_data["description"] if db_data["description"] else ""
            severity_label = db_data["severity"] if db_data["severity"] else None
            installed_versions = list(db_data["installed_versions"]) if db_data["installed_versions"] else []
            fixed_versions = list(db_data["fixed_versions"]) if db_data["fixed_versions"] else []
            
            # Generate summary from description
            if details:
                # Clean markdown headers and extract first meaningful sentence
                lines = [line.strip() for line in details.split('\n') if line.strip()]
                # Skip markdown headers (###, ##, #)
                for line in lines:
                    if not line.startswith('#') and len(line) > 20:
                        # Take first sentence or first 120 chars
                        if '.' in line:
                            summary = line.split('.')[0].strip()
                        else:
                            summary = line[:120].strip()
                        if len(summary) > 150:
                            summary = summary[:147] + "..."
                        break
                else:
                    # Fallback if no good line found
                    summary = lines[0] if lines else f"Security vulnerability in {package_name}"
                    if len(summary) > 150:
                        summary = summary[:147] + "..."
            else:
                summary = f"Security vulnerability in {package_name}"
            
            print(f"\n‚úì Auto-filled from database:")
            print(f"  Summary: {summary}")
            print(f"  Aliases: {', '.join(aliases) if aliases else 'None'}")
            print(f"  Severity: {severity_label or 'None'}")
        else:
            # User wants to enter manually
            aliases = []
            summary = ""
            details = ""
            severity_label = None
            installed_versions = []
            fixed_versions = []
    else:
        # No database data found
        print("\n‚ö†Ô∏è  No data found in database for this package. Entering manual mode.")
        aliases = []
        summary = ""
        details = ""
        severity_label = None
        installed_versions = []
        fixed_versions = []
    
    # Get summary (if not auto-filled)
    if not summary:
        summary = input("\nSummary (brief one-line description): ").strip()
    
    # Get details (if not auto-filled)
    if not details:
        details = get_multiline_input("Details (detailed description, press '.' when done):", allow_empty=True)
    
    # Get additional aliases if needed
    if not aliases or input("\nAdd more aliases? (y/N): ").strip().lower() == 'y':
        extra_aliases = get_list_input(
            "Additional aliases (comma-separated, e.g., CVE-2025-1234, GHSA-xxxx):",
            allow_empty=True,
        )
        if extra_aliases:
            alias_set = set(aliases)
            alias_set.update(extra_aliases)
            aliases = sorted(alias_set)
    
    # Get CVSS score or severity
    severity = []
    cvss_score = input("\nCVSS v3 score (e.g., CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N) [optional]: ").strip()
    if cvss_score:
        severity.append({
            "type": "CVSS_V3",
            "score": cvss_score
        })
    elif severity_label:
        # Use auto-filled severity from database
        severity.append({
            "type": "CUSTOM",
            "score": severity_label
        })
    else:
        severity_input = input("Severity label (LOW/MEDIUM/HIGH/CRITICAL) [optional]: ").strip().upper()
        if severity_input:
            severity.append({
                "type": "CUSTOM",
                "score": severity_input
            })
    
    # Get version ranges
    print("\n" + "-" * 60)
    print("Version Ranges (leave blank to skip)")
    print("-" * 60)
    ranges = []
    
    # Auto-generate ranges from fixed_versions if available
    if fixed_versions:
        print(f"\nFound fixed versions in database: {', '.join(fixed_versions)}")
        auto_ranges = input("Auto-generate ranges from fixed versions? (Y/n): ").strip().lower()
        if auto_ranges != 'n':
            for fv in fixed_versions:
                # Try to extract base version (e.g., 1.12.14 -> 1.12.0)
                parts = fv.split('.')
                if len(parts) >= 2:
                    introduced = f"{parts[0]}.{parts[1]}.0"
                else:
                    introduced = "0"
                
                ranges.append({
                    "type": "ECOSYSTEM",
                    "events": [
                        {"introduced": introduced},
                        {"fixed": fv}
                    ]
                })
            print(f"‚úì Generated {len(ranges)} version range(s)")
    
    # Allow manual addition of ranges
    if ranges:
        add_more = input("\nAdd more version ranges manually? (y/N): ").strip().lower()
    else:
        add_more = input("\nAdd version ranges? (y/N): ").strip().lower()
    
    if add_more == 'y':
        while True:
            introduced = input("  Introduced version (or blank to finish): ").strip()
            if not introduced:
                break
            fixed = input("  Fixed version (or blank if not fixed): ").strip()
            
            events = [{"introduced": introduced}]
            if fixed:
                events.append({"fixed": fixed})
            
            ranges.append({
                "type": "ECOSYSTEM",
                "events": events
            })
            
            more = input("  Add another range? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Get explicit versions
    if installed_versions:
        print(f"\nFound installed versions in database: {', '.join(installed_versions)}")
        use_installed = input("Use these as affected versions? (Y/n): ").strip().lower()
        if use_installed != 'n':
            versions = installed_versions
        else:
            versions = get_list_input("Explicit affected versions (comma-separated) [optional]:", allow_empty=True)
    else:
        versions = get_list_input("Explicit affected versions (comma-separated) [optional]:", allow_empty=True)
    
    # Get references
    print("\n" + "-" * 60)
    print("References (URLs)")
    print("-" * 60)
    references = []
    
    # Auto-generate references from aliases
    if aliases:
        auto_refs = []
        for alias in aliases:
            if alias.startswith("GHSA-"):
                url = f"https://github.com/advisories/{alias}"
                auto_refs.append({"type": "ADVISORY", "url": url})
            elif alias.startswith("CVE-"):
                url = f"https://nvd.nist.gov/vuln/detail/{alias}"
                auto_refs.append({"type": "WEB", "url": url})
        
        if auto_refs:
            print(f"\nAuto-generated {len(auto_refs)} reference(s) from aliases:")
            for ref in auto_refs:
                print(f"  {ref['type']}: {ref['url']}")
            use_auto = input("Use these references? (Y/n): ").strip().lower()
            if use_auto != 'n':
                references = auto_refs
    
    # Allow manual addition
    if references:
        add_more_refs = input("\nAdd more references manually? (y/N): ").strip().lower()
    else:
        add_more_refs = input("\nAdd references? (y/N): ").strip().lower()
    
    if add_more_refs == 'y':
        while True:
            url = input("  URL: ").strip()
            if not url:
                break
            ref_type = input("  Type (ADVISORY/WEB/PACKAGE) [WEB]: ").strip().upper() or "WEB"
            
            # Check for duplicates
            if not any(r["url"] == url for r in references):
                references.append({
                    "type": ref_type,
                    "url": url
                })
            else:
                print("  ‚ö†Ô∏è  Reference already added, skipping.")
            
            more = input("  Add another reference? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Create vulnerability JSON
    vuln_data = create_comprehensive_vulnerability_json(
        vuln_id=vuln_id,
        package_name=package_name,
        summary=summary,
        details=details,
        aliases=aliases,
        references=references,
        severity=severity,
        ranges=ranges if ranges else None,
        versions=versions if versions else None
    )
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n‚úì Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_single_vulnerability_simple():
    """
    Interactive mode to create a simple vulnerability file (minimal fields).
    """
    print("\n" + "=" * 60)
    print("Simple Vulnerability Creation (Minimal Fields)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (or leave blank for placeholder): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    summary = (
        input("\nSummary (optional): ").strip()
        or f"Placeholder advisory for {package_name}."
    )
    details = (
        get_multiline_input("Details (optional, press '.' when done):", allow_empty=True)
        or f"A placeholder advisory for {package_name}. Update this entry with the accurate vulnerability description."
    )

    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    affected_entry = {
        "package": {
            "ecosystem": "CLEANSTART",
            "name": package_name
        },
        "ranges": [
            {
                "type": "ECOSYSTEM",
                "events": [
                    {"introduced": "0"}
                ]
            }
        ]
    }

    vuln_data = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "published": timestamp,
        "withdrawn": None,
        "aliases": [],
        "summary": summary,
        "details": details,
        "affected": [affected_entry],
        "references": [],
        "severity": [],
    }
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n‚úì Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_batch_vulnerabilities():
    """
    Batch mode to create multiple simple vulnerability files.
    """
    print("\n" + "=" * 60)
    print("Batch Vulnerability Creation (Simple Format)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Get count
    count_input = input("\nHow many vulnerability files to create? (default: 5): ").strip()
    count = int(count_input) if count_input else 5
    
    # Get package names
    print("\nEnter package names (comma-separated, or leave blank for placeholders):")
    package_input = input("Package names: ").strip()
    
    package_names = None
    if package_input:
        package_names = [name.strip() for name in package_input.split(",")]
        print(f"  Using packages: {', '.join(package_names)}")
        if len(package_names) < count:
            print(f"  (Remaining {count - len(package_names)} files will use placeholder)")
    
    # Show info about random ID generation
    print(f"\nIDs will be generated randomly (format: LLNNNNN)")
    
    # Confirm
    print("\n" + "=" * 60)
    print(f"About to create {count} vulnerability files for year {year}")
    print("=" * 60)
    confirm = input("Proceed? (Y/n): ").strip().lower()
    
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Generate files
    created_files = []
    print(f"\nGenerating {count} vulnerability files...")
    print("-" * 60)
    
    for i in range(count):
        # Generate random ID
        vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
        
        # Determine package name
        if package_names and i < len(package_names):
            package_name = package_names[i]
        else:
            package_name = "{package_name}"
        
            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
            affected_entry = {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                },
                "ranges": [
                    {
                        "type": "ECOSYSTEM",
                        "events": [
                            {"introduced": "0"}
                        ]
                    }
                ]
            }
            summary = f"Placeholder advisory for {package_name}."
            details = (
                f"This placeholder advisory reserves an ID for {package_name}. "
                f"Replace this text with the real vulnerability description."
            )
            
            vuln_data = {
                "schema_version": "1.7.3",
                "id": vuln_id,
                "modified": timestamp,
                "published": timestamp,
                "withdrawn": None,
                "aliases": [],
                "summary": summary,
                "details": details,
                "affected": [affected_entry],
                "references": [],
                "severity": [],
            }
        
        filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
        
        created_files.append(filepath)
        print(f"‚úì Created: {vuln_id}.json" + (f" (package: {package_name})" if package_name != "{package_name}" else ""))
    
    print("-" * 60)
    print(f"\n‚úì Successfully created {len(created_files)} files in:")
    print(f"  {vulnerabilities_dir.absolute()}")




def create_advisories_from_scan_results():
    """Generate OSV advisories directly from scan_results JSON files."""
    print("\n" + "=" * 60)
    print("Generate advisories from scan_results")
    print("=" * 60)

    current_year = datetime.now().year
    year_input = input(f"\nEnter year for advisories (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year

    default_scan_dir = SCAN_RESULTS_DIR
    scan_input = input(
        f"Scan results directory (default: {default_scan_dir}): "
    ).strip()
    scan_root = Path(scan_input) if scan_input else default_scan_dir

    try:
        records = collect_scan_records(scan_root)
    except FileNotFoundError as exc:
        print(f"‚úó {exc}")
        return

    if not records:
        print("\nNo vulnerabilities were found in the provided scan results.")
        return

    limit_input = input(
        f"Found {len(records)} artifacts with vulnerabilities. Limit how many to import? (press Enter for all): "
    ).strip()
    if limit_input:
        try:
            limit = int(limit_input)
            records = records[:max(limit, 0)]
        except ValueError:
            print("Invalid limit specified, importing all records.")

    year_dir = ADVISORIES_DIR / str(year)
    print(f"\nAbout to create {len(records)} advisories in {year_dir}")
    confirm = input("Proceed? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return

    created = []
    for record in records:
        advisories = build_advisories_from_scan(record, year, year_dir)
        if not advisories:
            continue
        for advisory in advisories:
            filepath = save_vulnerability(advisory, year_dir)
            created.append(filepath.name)
            print(
                f"‚úì Created advisory {filepath.name} for {record['artifact']} "
                f"({', '.join(advisory['aliases'])})"
            )

    print("\n" + "-" * 60)
    print(f"‚úì Generated {len(created)} advisories in {year_dir.resolve()}")


def main():
    """
    Main function - provides mode selection.
    """
    print("=" * 60)
    print("CleanStart Vulnerability Generator")
    print("=" * 60)
    print("\nSelect mode:")
    print("  1. Create single vulnerability (detailed with all fields)")
    print("  2. Create single vulnerability (simple - minimal fields)")
    print("  3. Create multiple vulnerabilities (batch - simple format)")
    print("  4. Generate advisories from scan_results")
    print("  5. Exit")
    
    choice = input("\nEnter choice (1/2/3/4/5): ").strip()
    
    if choice == "1":
        create_single_vulnerability_detailed()
    elif choice == "2":
        create_single_vulnerability_simple()
    elif choice == "3":
        create_batch_vulnerabilities()
    elif choice == "4":
        create_advisories_from_scan_results()
    elif choice == "5":
        print("Exiting.")
        return
    else:
        print("Invalid choice. Please run the script again.")
        return


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nCancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚úó Error: {e}", file=sys.stderr)
        sys.exit(1)
