#!/usr/bin/env python3
"""
Script to generate CleanStart vulnerability JSON files in OSV format.
Supports both single and batch creation with comprehensive fields.
Creates files with the format: CLEANSTART-YYYY-LLNNNNN.json
"""

import json
import os
import subprocess
import sys
import random
import string
from collections import defaultdict
from datetime import datetime
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
ADVISORIES_DIR = BASE_DIR / "advisories"
SCAN_RESULTS_DIR = BASE_DIR / "scan_results"
SCHEMA_PATH = BASE_DIR / "validation" / "schemas" / "osv-schema-1.7.3.json"

SEVERITY_ORDER = {
    "CRITICAL": 5,
    "HIGH": 4,
    "MEDIUM": 3,
    "LOW": 2,
    "UNKNOWN": 1,
    "NEGLIGIBLE": 1,
}


def validate_osv_file(json_path):
    """Validate a vulnerability JSON against the OSV schema using check-jsonschema."""
    if not SCHEMA_PATH.exists():
        print(f"  ! Schema file not found at {SCHEMA_PATH}. Skipping validation.")
        return

    cmd = [
        "check-jsonschema",
        "--schemafile",
        str(SCHEMA_PATH),
        str(json_path),
    ]
    try:
        subprocess.run(cmd, check=True, capture_output=True, text=True)
        print(f"  ✓ Schema validation passed for {json_path.name}")
    except FileNotFoundError:
        print("  ! check-jsonschema command not found. Install it to enable auto-validation.")
    except subprocess.CalledProcessError as exc:
        print(f"  ✗ Schema validation failed for {json_path}")
        if exc.stdout:
            print(exc.stdout.strip())
        if exc.stderr:
            print(exc.stderr.strip())
        raise



def get_existing_ids(vulnerabilities_dir):
    """
    Get all existing vulnerability ID numbers for the given year directory.
    Returns a set of ID suffixes (e.g., 'AB12345').
    """
    existing_ids = set()
    
    if not vulnerabilities_dir.exists():
        return existing_ids
    
    # Find all existing vulnerability files
    existing_files = list(vulnerabilities_dir.glob("CLEANSTART-*.json"))
    
    for file in existing_files:
        filename = file.stem  # Remove .json extension
        # Extract the ID suffix (e.g., AB12345)
        parts = filename.split("-")
        if len(parts) == 3:
            existing_ids.add(parts[2])
    
    return existing_ids


def generate_random_vulnerability_id(year, vulnerabilities_dir):
    """
    Generates a random vulnerability ID for the given year.
    Format: CLEANSTART-YYYY-LLNNNNN (2 uppercase letters + 5 digits)
    Ensures the ID doesn't already exist.
    """
    existing_ids = get_existing_ids(vulnerabilities_dir)
    
    # Generate random ID with 2 letters + 5 digits
    max_attempts = 100
    for _ in range(max_attempts):
        # Generate 2 random uppercase letters
        letters = ''.join(random.choices(string.ascii_uppercase, k=2))
        # Generate 5 random digits
        numbers = ''.join(random.choices(string.digits, k=5))
        id_suffix = f"{letters}{numbers}"
        
        if id_suffix not in existing_ids:
            return f"CLEANSTART-{year}-{id_suffix}"
    
    # If we couldn't find a random ID (very unlikely), try systematically
    for letter1 in string.ascii_uppercase:
        for letter2 in string.ascii_uppercase:
            for num in range(100000):
                id_suffix = f"{letter1}{letter2}{num:05d}"
                if id_suffix not in existing_ids:
                    return f"CLEANSTART-{year}-{id_suffix}"
    
    raise ValueError("No available ID numbers (all IDs used for this year)")



def normalize_severity(value):
    """Normalize severity strings to uppercase keywords."""
    if not value:
        return "UNKNOWN"
    return str(value).strip().upper()


def severity_rank(value):
    """Convert severity labels to numeric ranks for comparisons."""
    return SEVERITY_ORDER.get(normalize_severity(value), 0)


def collect_scan_records(scan_root):
    """Walk the scan_results tree and gather vulnerability records."""
    scan_root = Path(scan_root)
    if not scan_root.exists():
        raise FileNotFoundError(f"Scan results directory not found: {scan_root}")

    records = []
    for vuln_file in scan_root.rglob("vulnerabilities.json"):
        try:
            with open(vuln_file, encoding="utf-8") as fh:
                data = json.load(fh)
        except Exception as exc:
            print(f"  ! Skipping {vuln_file}: {exc}")
            continue

        metadata = data.get("Metadata") or {}
        artifact = (
            data.get("ArtifactName")
            or (metadata.get("RepoTags") or [None])[0]
            or (metadata.get("RepoDigests") or [None])[0]
            or vuln_file.parent.name
        )

        results = data.get("Results") or []
        vulnerabilities = []
        for result in results:
            for vuln in result.get("Vulnerabilities") or []:
                cve = (
                    vuln.get("VulnerabilityID")
                    or vuln.get("CVE")
                    or vuln.get("id")
                    or vuln.get("ID")
                )
                if not cve:
                    continue
                pkg_name = (
                    vuln.get("PkgName")
                    or vuln.get("pkgName")
                    or vuln.get("PackageName")
                    or "unknown-package"
                )
                vulnerabilities.append(
                    {
                        "cve": cve,
                        "package": pkg_name,
                        "pkg_type": vuln.get("PkgType") or vuln.get("PkgPath"),
                        "installed_version": vuln.get("InstalledVersion") or vuln.get("PkgVersion"),
                        "fixed_version": vuln.get("FixedVersion"),
                        "severity": normalize_severity(vuln.get("Severity")),
                        "description": vuln.get("Description") or vuln.get("Title") or "",
                        "primary_url": vuln.get("PrimaryURL"),
                        "references": vuln.get("References") or [],
                    }
                )

        if not vulnerabilities:
            continue

        records.append(
            {
                "artifact": artifact,
                "folder": vuln_file.relative_to(scan_root).parent.as_posix(),
                "path": vuln_file,
                "created_at": data.get("CreatedAt"),
                "vulnerabilities": vulnerabilities,
            }
        )
    return records



def build_details_text(record):
    """Create templated prose summarizing vulnerabilities for an artifact."""
    lines = [
        f"Automated import from scan folder `{record['folder']}` for artifact `{record['artifact']}` "
        f"detected {len(record['vulnerabilities'])} vulnerabilities.",
        "",
        "The scanner reported the following CVEs:",
    ]
    for vuln in record["vulnerabilities"]:
        version = vuln.get("installed_version") or ""
        desc = vuln["description"] or "No description provided."
        lines.append(
            f"- {vuln['cve']} ({vuln['severity']}) in {vuln['package']} {version}: {desc}"
        )
    return "\n".join(lines)


def build_advisory_from_scan(record, year, year_dir):
    """Convert a scan record into an OSV-style advisory document."""
    vuln_id = generate_random_vulnerability_id(year, year_dir)
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

    aliases = sorted({v["cve"] for v in record["vulnerabilities"]})
    summary = (
        f"{record['artifact']} scan detected {len(aliases)} tracked vulnerabilities"
    )
    details = build_details_text(record)

    package_map = defaultdict(
        lambda: {"versions": set(), "cves": set(), "paths": set(), "fixed": set()}
    )
    reference_urls = set()

    for vuln in record["vulnerabilities"]:
        pkg_key = vuln["package"]
        if vuln.get("installed_version"):
            package_map[pkg_key]["versions"].add(vuln.get("installed_version"))
        package_map[pkg_key]["cves"].add(vuln["cve"])
        if vuln.get("pkg_type"):
            package_map[pkg_key]["paths"].add(vuln["pkg_type"])
        if vuln.get("fixed_version"):
            package_map[pkg_key]["fixed"].add(vuln["fixed_version"])
        if vuln.get("primary_url"):
            reference_urls.add(vuln["primary_url"])
        for ref in vuln.get("references") or []:
            reference_urls.add(ref)

    affected = []
    for pkg, meta in package_map.items():
        entry = {"package": {"ecosystem": "CLEANSTART", "name": pkg}}
        versions = sorted(meta["versions"])
        if versions:
            entry["versions"] = versions
        database_specific = {}
        if meta["cves"]:
            database_specific["cves"] = sorted(meta["cves"])
        if meta["paths"]:
            database_specific["locations"] = sorted(meta["paths"])
        if meta["fixed"]:
            database_specific["fixed_versions"] = sorted(meta["fixed"])
        if database_specific:
            entry["database_specific"] = database_specific
        affected.append(entry)

    top_severity = "UNKNOWN"
    if record["vulnerabilities"]:
        top_severity = max(
            (v["severity"] for v in record["vulnerabilities"]),
            key=severity_rank,
            default="UNKNOWN",
        )

    references = [
        {"type": "SCAN_REPORT", "url": f"file://{record['path']}"}
    ]
    for url in sorted(reference_urls):
        if url:
            references.append({"type": "WEB", "url": url})

    return {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "published": timestamp,
        "withdrawn": None,
        "aliases": aliases,
        "upstream": aliases,
        "summary": summary,
        "details": details,
        "affected": affected,
        "references": references,
        "severity": [
            {
                "type": "SCAN_SEVERITY",
                "score": top_severity,
            }
        ],
        "database_specific": {
            "source_scan_folder": record["folder"],
            "artifact": record["artifact"],
            "generated_from_scan": True,
        },
    }

def get_multiline_input(prompt, allow_empty=False):
    """
    Get multiline input from user.
    """
    print(f"\n{prompt}")
    print("(Press Ctrl+D or Ctrl+Z then Enter when done, or enter '.' on a line by itself)")
    lines = []
    try:
        while True:
            line = input()
            if line == '.':
                break
            lines.append(line)
    except EOFError:
        pass
    
    result = '\n'.join(lines).strip()
    if not result and not allow_empty:
        return None
    return result


def get_list_input(prompt, allow_empty=True):
    """
    Get comma-separated list input from user.
    """
    response = input(f"\n{prompt}\n> ").strip()
    if not response:
        return [] if allow_empty else None
    return [item.strip() for item in response.split(',') if item.strip()]


def create_comprehensive_vulnerability_json(vuln_id, package_name="{package_name}", 
                                           summary="", details="", aliases=None, 
                                           upstream=None, references=None, 
                                           severity=None, ranges=None, versions=None,
                                           published=None, withdrawn=None):
    """
    Creates a comprehensive vulnerability JSON object with all OSV fields.
    """
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    
    vulnerability = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "published": published or timestamp,
        "withdrawn": withdrawn,
        "aliases": aliases or [],
        "upstream": upstream or [],
        "summary": summary or f"Security vulnerability in {package_name}",
        "details": details or "",
        "affected": [
            {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                }
            }
        ],
        "references": references or [],
        "severity": severity or []
    }
    
    # Add ranges if provided
    if ranges:
        vulnerability["affected"][0]["ranges"] = ranges
    
    # Add explicit versions if provided
    if versions:
        vulnerability["affected"][0]["versions"] = versions
    
    return vulnerability


def save_vulnerability(vuln_data, vulnerabilities_dir):
    """
    Saves the vulnerability JSON to the appropriate directory.
    """
    # Create directory structure if it doesn't exist
    vulnerabilities_dir.mkdir(parents=True, exist_ok=True)
    
    # Create filename
    vuln_id = vuln_data["id"]
    filename = f"{vuln_id}.json"
    filepath = vulnerabilities_dir / filename
    
    # Save JSON file with proper formatting
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(vuln_data, f, indent=2, ensure_ascii=False)

    validate_osv_file(filepath)
    
    return filepath


def create_single_vulnerability_detailed():
    """
    Interactive mode to create a single comprehensive vulnerability file.
    """
    print("\n" + "=" * 60)
    print("Detailed Vulnerability Creation")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (required): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    # Get summary
    summary = input("\nSummary (brief one-line description): ").strip()
    
    # Get details
    details = get_multiline_input("Details (detailed description, press '.' when done):", allow_empty=True)
    
    # Get aliases (CVE IDs, etc.)
    aliases = get_list_input("Aliases (comma-separated, e.g., CVE-2025-1234, BIT-python-2025-1234):", allow_empty=True)
    
    # Get upstream references
    upstream = get_list_input("Upstream references (comma-separated, e.g., CVE-2025-1234):", allow_empty=True)
    
    # Get CVSS score
    cvss_score = input("\nCVSS v3 score (e.g., CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N) [optional]: ").strip()
    severity = []
    if cvss_score:
        severity.append({
            "type": "CVSS_V3",
            "score": cvss_score
        })
    
    # Get version ranges
    print("\n" + "-" * 60)
    print("Version Ranges (leave blank to skip)")
    print("-" * 60)
    ranges = []
    add_ranges = input("Add version ranges? (y/N): ").strip().lower()
    if add_ranges == 'y':
        while True:
            introduced = input("  Introduced version (or blank to finish): ").strip()
            if not introduced:
                break
            fixed = input("  Fixed version (or blank if not fixed): ").strip()
            
            events = [{"introduced": introduced}]
            if fixed:
                events.append({"fixed": fixed})
            
            ranges.append({
                "type": "ECOSYSTEM",
                "events": events
            })
            
            more = input("  Add another range? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Get explicit versions
    versions = get_list_input("Explicit affected versions (comma-separated) [optional]:", allow_empty=True)
    
    # Get references
    print("\n" + "-" * 60)
    print("References (URLs)")
    print("-" * 60)
    references = []
    add_refs = input("Add references? (y/N): ").strip().lower()
    if add_refs == 'y':
        while True:
            url = input("  URL: ").strip()
            if not url:
                break
            ref_type = input("  Type (ADVISORY/WEB/PACKAGE) [WEB]: ").strip().upper() or "WEB"
            
            references.append({
                "type": ref_type,
                "url": url
            })
            
            more = input("  Add another reference? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Create vulnerability JSON
    vuln_data = create_comprehensive_vulnerability_json(
        vuln_id=vuln_id,
        package_name=package_name,
        summary=summary,
        details=details,
        aliases=aliases,
        upstream=upstream,
        references=references,
        severity=severity,
        ranges=ranges if ranges else None,
        versions=versions if versions else None
    )
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n✓ Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_single_vulnerability_simple():
    """
    Interactive mode to create a simple vulnerability file (minimal fields).
    """
    print("\n" + "=" * 60)
    print("Simple Vulnerability Creation (Minimal Fields)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (or leave blank for placeholder): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    # Create minimal vulnerability JSON
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    vuln_data = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "affected": [
            {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                }
            }
        ]
    }
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n✓ Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_batch_vulnerabilities():
    """
    Batch mode to create multiple simple vulnerability files.
    """
    print("\n" + "=" * 60)
    print("Batch Vulnerability Creation (Simple Format)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = ADVISORIES_DIR / str(year)
    
    # Get count
    count_input = input("\nHow many vulnerability files to create? (default: 5): ").strip()
    count = int(count_input) if count_input else 5
    
    # Get package names
    print("\nEnter package names (comma-separated, or leave blank for placeholders):")
    package_input = input("Package names: ").strip()
    
    package_names = None
    if package_input:
        package_names = [name.strip() for name in package_input.split(",")]
        print(f"  Using packages: {', '.join(package_names)}")
        if len(package_names) < count:
            print(f"  (Remaining {count - len(package_names)} files will use placeholder)")
    
    # Show info about random ID generation
    print(f"\nIDs will be generated randomly (format: LLNNNNN)")
    
    # Confirm
    print("\n" + "=" * 60)
    print(f"About to create {count} vulnerability files for year {year}")
    print("=" * 60)
    confirm = input("Proceed? (Y/n): ").strip().lower()
    
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Generate files
    created_files = []
    print(f"\nGenerating {count} vulnerability files...")
    print("-" * 60)
    
    for i in range(count):
        # Generate random ID
        vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
        
        # Determine package name
        if package_names and i < len(package_names):
            package_name = package_names[i]
        else:
            package_name = "{package_name}"
        
        # Create simple vulnerability JSON
        timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
        vuln_data = {
            "schema_version": "1.7.3",
            "id": vuln_id,
            "modified": timestamp,
            "affected": [
                {
                    "package": {
                        "ecosystem": "CLEANSTART",
                        "name": package_name
                    }
                }
            ]
        }
        
        filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
        
        created_files.append(filepath)
        print(f"✓ Created: {vuln_id}.json" + (f" (package: {package_name})" if package_name != "{package_name}" else ""))
    
    print("-" * 60)
    print(f"\n✓ Successfully created {len(created_files)} files in:")
    print(f"  {vulnerabilities_dir.absolute()}")




def create_advisories_from_scan_results():
    """Generate OSV advisories directly from scan_results JSON files."""
    print("\n" + "=" * 60)
    print("Generate advisories from scan_results")
    print("=" * 60)

    current_year = datetime.now().year
    year_input = input(f"\nEnter year for advisories (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year

    default_scan_dir = SCAN_RESULTS_DIR
    scan_input = input(
        f"Scan results directory (default: {default_scan_dir}): "
    ).strip()
    scan_root = Path(scan_input) if scan_input else default_scan_dir

    try:
        records = collect_scan_records(scan_root)
    except FileNotFoundError as exc:
        print(f"✗ {exc}")
        return

    if not records:
        print("\nNo vulnerabilities were found in the provided scan results.")
        return

    limit_input = input(
        f"Found {len(records)} artifacts with vulnerabilities. Limit how many to import? (press Enter for all): "
    ).strip()
    if limit_input:
        try:
            limit = int(limit_input)
            records = records[:max(limit, 0)]
        except ValueError:
            print("Invalid limit specified, importing all records.")

    year_dir = ADVISORIES_DIR / str(year)
    print(f"\nAbout to create {len(records)} advisories in {year_dir}")
    confirm = input("Proceed? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return

    created = []
    for record in records:
        advisory = build_advisory_from_scan(record, year, year_dir)
        filepath = save_vulnerability(advisory, year_dir)
        created.append(filepath.name)
        print(f"✓ Created advisory {filepath.name} for {record['artifact']}")

    print("\n" + "-" * 60)
    print(f"✓ Generated {len(created)} advisories in {year_dir.resolve()}")


def main():
    """
    Main function - provides mode selection.
    """
    print("=" * 60)
    print("CleanStart Vulnerability Generator")
    print("=" * 60)
    print("\nSelect mode:")
    print("  1. Create single vulnerability (detailed with all fields)")
    print("  2. Create single vulnerability (simple - minimal fields)")
    print("  3. Create multiple vulnerabilities (batch - simple format)")
    print("  4. Generate advisories from scan_results")
    print("  5. Exit")
    
    choice = input("\nEnter choice (1/2/3/4/5): ").strip()
    
    if choice == "1":
        create_single_vulnerability_detailed()
    elif choice == "2":
        create_single_vulnerability_simple()
    elif choice == "3":
        create_batch_vulnerabilities()
    elif choice == "4":
        create_advisories_from_scan_results()
    elif choice == "5":
        print("Exiting.")
        return
    else:
        print("Invalid choice. Please run the script again.")
        return


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nCancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\n✗ Error: {e}", file=sys.stderr)
        sys.exit(1)
