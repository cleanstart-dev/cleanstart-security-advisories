#!/usr/bin/env python3
"""
Script to generate CleanStart vulnerability JSON files in OSV format.
Supports both single and batch creation with comprehensive fields.
Creates files with the format: CLEANSTART-YYYY-LLNNNNN.json
"""

import json
import os
import sys
import random
import string
from datetime import datetime
from pathlib import Path


def get_existing_ids(vulnerabilities_dir):
    """
    Get all existing vulnerability ID numbers for the given year directory.
    Returns a set of ID suffixes (e.g., 'AB12345').
    """
    existing_ids = set()
    
    if not vulnerabilities_dir.exists():
        return existing_ids
    
    # Find all existing vulnerability files
    existing_files = list(vulnerabilities_dir.glob("CLEANSTART-*.json"))
    
    for file in existing_files:
        filename = file.stem  # Remove .json extension
        # Extract the ID suffix (e.g., AB12345)
        parts = filename.split("-")
        if len(parts) == 3:
            existing_ids.add(parts[2])
    
    return existing_ids


def generate_random_vulnerability_id(year, vulnerabilities_dir):
    """
    Generates a random vulnerability ID for the given year.
    Format: CLEANSTART-YYYY-LLNNNNN (2 uppercase letters + 5 digits)
    Ensures the ID doesn't already exist.
    """
    existing_ids = get_existing_ids(vulnerabilities_dir)
    
    # Generate random ID with 2 letters + 5 digits
    max_attempts = 100
    for _ in range(max_attempts):
        # Generate 2 random uppercase letters
        letters = ''.join(random.choices(string.ascii_uppercase, k=2))
        # Generate 5 random digits
        numbers = ''.join(random.choices(string.digits, k=5))
        id_suffix = f"{letters}{numbers}"
        
        if id_suffix not in existing_ids:
            return f"CLEANSTART-{year}-{id_suffix}"
    
    # If we couldn't find a random ID (very unlikely), try systematically
    for letter1 in string.ascii_uppercase:
        for letter2 in string.ascii_uppercase:
            for num in range(100000):
                id_suffix = f"{letter1}{letter2}{num:05d}"
                if id_suffix not in existing_ids:
                    return f"CLEANSTART-{year}-{id_suffix}"
    
    raise ValueError("No available ID numbers (all IDs used for this year)")


def get_multiline_input(prompt, allow_empty=False):
    """
    Get multiline input from user.
    """
    print(f"\n{prompt}")
    print("(Press Ctrl+D or Ctrl+Z then Enter when done, or enter '.' on a line by itself)")
    lines = []
    try:
        while True:
            line = input()
            if line == '.':
                break
            lines.append(line)
    except EOFError:
        pass
    
    result = '\n'.join(lines).strip()
    if not result and not allow_empty:
        return None
    return result


def get_list_input(prompt, allow_empty=True):
    """
    Get comma-separated list input from user.
    """
    response = input(f"\n{prompt}\n> ").strip()
    if not response:
        return [] if allow_empty else None
    return [item.strip() for item in response.split(',') if item.strip()]


def create_comprehensive_vulnerability_json(vuln_id, package_name="{package_name}", 
                                           summary="", details="", aliases=None, 
                                           upstream=None, references=None, 
                                           severity=None, ranges=None, versions=None,
                                           published=None, withdrawn=None):
    """
    Creates a comprehensive vulnerability JSON object with all OSV fields.
    """
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    
    vulnerability = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "published": published or timestamp,
        "withdrawn": withdrawn,
        "aliases": aliases or [],
        "upstream": upstream or [],
        "summary": summary or f"Security vulnerability in {package_name}",
        "details": details or "",
        "affected": [
            {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                }
            }
        ],
        "references": references or [],
        "severity": severity or []
    }
    
    # Add ranges if provided
    if ranges:
        vulnerability["affected"][0]["ranges"] = ranges
    
    # Add explicit versions if provided
    if versions:
        vulnerability["affected"][0]["versions"] = versions
    
    return vulnerability


def save_vulnerability(vuln_data, vulnerabilities_dir):
    """
    Saves the vulnerability JSON to the appropriate directory.
    """
    # Create directory structure if it doesn't exist
    vulnerabilities_dir.mkdir(parents=True, exist_ok=True)
    
    # Create filename
    vuln_id = vuln_data["id"]
    filename = f"{vuln_id}.json"
    filepath = vulnerabilities_dir / filename
    
    # Save JSON file with proper formatting
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(vuln_data, f, indent=2, ensure_ascii=False)
    
    return filepath


def create_single_vulnerability_detailed():
    """
    Interactive mode to create a single comprehensive vulnerability file.
    """
    print("\n" + "=" * 60)
    print("Detailed Vulnerability Creation")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = Path(__file__).parent.parent / "vulnerabilities" / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (required): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    # Get summary
    summary = input("\nSummary (brief one-line description): ").strip()
    
    # Get details
    details = get_multiline_input("Details (detailed description, press '.' when done):", allow_empty=True)
    
    # Get aliases (CVE IDs, etc.)
    aliases = get_list_input("Aliases (comma-separated, e.g., CVE-2025-1234, BIT-python-2025-1234):", allow_empty=True)
    
    # Get upstream references
    upstream = get_list_input("Upstream references (comma-separated, e.g., CVE-2025-1234):", allow_empty=True)
    
    # Get CVSS score
    cvss_score = input("\nCVSS v3 score (e.g., CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N) [optional]: ").strip()
    severity = []
    if cvss_score:
        severity.append({
            "type": "CVSS_V3",
            "score": cvss_score
        })
    
    # Get version ranges
    print("\n" + "-" * 60)
    print("Version Ranges (leave blank to skip)")
    print("-" * 60)
    ranges = []
    add_ranges = input("Add version ranges? (y/N): ").strip().lower()
    if add_ranges == 'y':
        while True:
            introduced = input("  Introduced version (or blank to finish): ").strip()
            if not introduced:
                break
            fixed = input("  Fixed version (or blank if not fixed): ").strip()
            
            events = [{"introduced": introduced}]
            if fixed:
                events.append({"fixed": fixed})
            
            ranges.append({
                "type": "ECOSYSTEM",
                "events": events
            })
            
            more = input("  Add another range? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Get explicit versions
    versions = get_list_input("Explicit affected versions (comma-separated) [optional]:", allow_empty=True)
    
    # Get references
    print("\n" + "-" * 60)
    print("References (URLs)")
    print("-" * 60)
    references = []
    add_refs = input("Add references? (y/N): ").strip().lower()
    if add_refs == 'y':
        while True:
            url = input("  URL: ").strip()
            if not url:
                break
            ref_type = input("  Type (ADVISORY/WEB/PACKAGE) [WEB]: ").strip().upper() or "WEB"
            
            references.append({
                "type": ref_type,
                "url": url
            })
            
            more = input("  Add another reference? (y/N): ").strip().lower()
            if more != 'y':
                break
    
    # Create vulnerability JSON
    vuln_data = create_comprehensive_vulnerability_json(
        vuln_id=vuln_id,
        package_name=package_name,
        summary=summary,
        details=details,
        aliases=aliases,
        upstream=upstream,
        references=references,
        severity=severity,
        ranges=ranges if ranges else None,
        versions=versions if versions else None
    )
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n✓ Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_single_vulnerability_simple():
    """
    Interactive mode to create a simple vulnerability file (minimal fields).
    """
    print("\n" + "=" * 60)
    print("Simple Vulnerability Creation (Minimal Fields)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = Path(__file__).parent.parent / "vulnerabilities" / str(year)
    
    # Generate random vulnerability ID
    vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
    print(f"\nGenerated ID: {vuln_id}")
    
    use_default = input(f"Use this ID? (Y/n): ").strip().lower()
    if use_default == 'n':
        custom_id = input("Enter custom ID (e.g., CLEANSTART-2025-AB12345): ").strip()
        vuln_id = custom_id if custom_id else vuln_id
    
    # Get package name
    package_name = input("\nPackage name (or leave blank for placeholder): ").strip()
    if not package_name:
        package_name = "{package_name}"
    
    # Create minimal vulnerability JSON
    timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    vuln_data = {
        "schema_version": "1.7.3",
        "id": vuln_id,
        "modified": timestamp,
        "affected": [
            {
                "package": {
                    "ecosystem": "CLEANSTART",
                    "name": package_name
                }
            }
        ]
    }
    
    # Preview
    print("\n" + "=" * 60)
    print("Preview of JSON to be created:")
    print("=" * 60)
    print(json.dumps(vuln_data, indent=2))
    
    # Confirm
    confirm = input("\nCreate this file? (Y/n): ").strip().lower()
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Save file
    filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
    print(f"\n✓ Successfully created: {filepath.name}")
    print(f"  Full path: {filepath.absolute()}")


def create_batch_vulnerabilities():
    """
    Batch mode to create multiple simple vulnerability files.
    """
    print("\n" + "=" * 60)
    print("Batch Vulnerability Creation (Simple Format)")
    print("=" * 60)
    
    # Get year
    current_year = datetime.now().year
    year_input = input(f"\nEnter year (default: {current_year}): ").strip()
    year = int(year_input) if year_input else current_year
    
    vulnerabilities_dir = Path(__file__).parent.parent / "vulnerabilities" / str(year)
    
    # Get count
    count_input = input("\nHow many vulnerability files to create? (default: 5): ").strip()
    count = int(count_input) if count_input else 5
    
    # Get package names
    print("\nEnter package names (comma-separated, or leave blank for placeholders):")
    package_input = input("Package names: ").strip()
    
    package_names = None
    if package_input:
        package_names = [name.strip() for name in package_input.split(",")]
        print(f"  Using packages: {', '.join(package_names)}")
        if len(package_names) < count:
            print(f"  (Remaining {count - len(package_names)} files will use placeholder)")
    
    # Show info about random ID generation
    print(f"\nIDs will be generated randomly (format: LLNNNNN)")
    
    # Confirm
    print("\n" + "=" * 60)
    print(f"About to create {count} vulnerability files for year {year}")
    print("=" * 60)
    confirm = input("Proceed? (Y/n): ").strip().lower()
    
    if confirm == 'n':
        print("Cancelled.")
        return
    
    # Generate files
    created_files = []
    print(f"\nGenerating {count} vulnerability files...")
    print("-" * 60)
    
    for i in range(count):
        # Generate random ID
        vuln_id = generate_random_vulnerability_id(year, vulnerabilities_dir)
        
        # Determine package name
        if package_names and i < len(package_names):
            package_name = package_names[i]
        else:
            package_name = "{package_name}"
        
        # Create simple vulnerability JSON
        timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
        vuln_data = {
            "schema_version": "1.7.3",
            "id": vuln_id,
            "modified": timestamp,
            "affected": [
                {
                    "package": {
                        "ecosystem": "CLEANSTART",
                        "name": package_name
                    }
                }
            ]
        }
        
        filepath = save_vulnerability(vuln_data, vulnerabilities_dir)
        
        created_files.append(filepath)
        print(f"✓ Created: {vuln_id}.json" + (f" (package: {package_name})" if package_name != "{package_name}" else ""))
    
    print("-" * 60)
    print(f"\n✓ Successfully created {len(created_files)} files in:")
    print(f"  {vulnerabilities_dir.absolute()}")


def main():
    """
    Main function - provides mode selection.
    """
    print("=" * 60)
    print("CleanStart Vulnerability Generator")
    print("=" * 60)
    print("\nSelect mode:")
    print("  1. Create single vulnerability (detailed with all fields)")
    print("  2. Create single vulnerability (simple - minimal fields)")
    print("  3. Create multiple vulnerabilities (batch - simple format)")
    print("  4. Exit")
    
    choice = input("\nEnter choice (1/2/3/4): ").strip()
    
    if choice == "1":
        create_single_vulnerability_detailed()
    elif choice == "2":
        create_single_vulnerability_simple()
    elif choice == "3":
        create_batch_vulnerabilities()
    elif choice == "4":
        print("Exiting.")
        return
    else:
        print("Invalid choice. Please run the script again.")
        return


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nCancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\n✗ Error: {e}", file=sys.stderr)
        sys.exit(1)
